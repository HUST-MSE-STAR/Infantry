# 2020届MSE STAR步兵

### 步兵功能需求

#### **运动**

基本移动动作：底盘两轴移动Z轴旋转、云台yaw/pitch轴旋转

小陀螺：底盘原地旋转，云台受操作手控制

底盘功率限制：步兵等级限制底盘最大功率

**射击**

单次/多次射击：

拨盘反拨：卡弹时拨盘电机反转

自瞄：云台指向受minipc控制

**遥控**

遥控器/键鼠操控：步兵运动姿态控制和模式切换

### 步兵开发板需求

#### **1.底盘开发板**

|     外设     |      作用      | 数量 | 接口型号 |
| :----------: | :------------: | ---- | -------- |
|    CAN1口    | 与C620电调通信 | 4    |  GH2.5  |
|    CAN2口    |  底盘云台通信  | 1    |  GH2.5   |
|     串口     | 与裁判系统通信 | 1    |   GH2.5   |
| 电源24V(out) |   给电调供电   | 4    |  XT30母   |
| 电源24V(in)  |  给开发板供电  | 1    |  XT30公  |

#### **2.云台开发板**

|     外设     |                作用                 | 数量 | 接口型号 |
| :----------: | :---------------------------------: | :--: | :------: |
|    CAN1口    | 6020电机(2)/2006电机(2)/3508电机(4) |  8   |   GH2.5 |
|    CAN2口    |            底盘云台通信             |  1   |   GH2.5  |
|     PWM      |       舱盖舵机(1)/枪管舵机(1)       |  2   |  ？？？  |
|     串口转USB     | minipc(1)// |  1   |  USB   |
| 串口 | imu模块(1)  | 1 | ？？？
| 串口 | dr16接收机(1)  | 1 | ？？？
|    GPIO口    |       触碰开关(2)       |  2   |  XH  |
| GPIO口 | 镭射激光(2) | 2 | ？？？
| 电源24V(out) |     电机供电(8)/弹丸充能装置(2)     |  10  | XT30母 |
| 电源19V(out) |            给minipc供电             |  1   | XT30母 |
| 电源24V(in)  |            给开发板供电             |  1   | XT30公 |

#### **3.其它需求**

|    外设    |          说明          |
| :--------: | :--------------------: |
|   LED灯    |    指示程序是否运行    |
|    串口    | 发送步兵各参数便于调试 |
| 程序下载口 |                        |

### 步兵程序结构

#### **1.底盘程序**

**Algorithm文件夹**：底盘程序需要的一些算法

|        文件名         |       说明       |
| :-------------------: | :--------------: |
| control_algorithm.c/h |   一些控制函数   |
|    crc8_crc16.c/h     | crc计算/校验函数 |

**Bsp文件夹**：底盘开发板外设的基本配置

|    文件名     |     说明     |
| :-----------: | :----------: |
|  bsp_can.c/h  | 一些基本配置 |
| bsp_usart.c/h | 一些基本配置 |

**Application文件夹**：步兵底盘的功能需求

|      文件名       |            实现的功能            |
| :---------------: | :------------------------------: |
|  can_receive.c/h  | 底盘电机数据、云台数据接收和解算 |
| power_control.c/h |           底盘功率控制           |
| chassis_task.c/h  |         底盘运动控制任务         |

#### 2.云台程序

**Algorithm文件夹**：云台程序需要的一些算法

|        文件名         |     说明     |
| :-------------------: | :----------: |
| control_algorithm.c/h | 一些控制函数 |

**Bsp文件夹**：云台开发板外设的基本配置

|    文件名     |     说明     |
| :-----------: | :----------: |
|  bsp_can.c/h  | 一些基本配置 |
| bsp_usart.c/h | 一些基本配置 |
|  bsp_pwm.c/h  | 一些基本配置 |
| bsp_gpio.c/h  | 一些基本配置 |

**Application文件夹**：步兵云台的功能需求

|         文件名         |          实现的功能          |
| :--------------------: | :--------------------------: |
|    can_receive.c/h     | 电机数据、底盘数据接收和解算 |
|   remote_control.c/h   |     遥控器数据接收和解算     |
|     pc_control.c/h     |     minipc数据接收和解算     |
|    imu_control.c/h     |      imu数据接收和解算       |
|    gimbal_task.c/h     |       云台姿态控制任务       |
|     shoot_task.c/h     |         射击控制任务         |
| communication_task.c/h |  云台与底盘/电调的交流任务   |

### 步兵程序具体说明

#### 1.串口通信

**配置**：

DMA接受与发送：无需 CPU 直接控制传输，使 CPU 的效率大为提高

空闲中断：接收完一帧数据时触发中断

双缓冲区功能：在处理一个缓冲区数据的时候，另外一个缓冲区能够正常接收数据

**说明**：步兵机器人使用串口进行遥控器数据、minipc数据、imu数据的定长接收和裁判系统数据的不定长接收，但串口的配置思路大同小异，下列程序以接收遥控器数据为例进行详细的注释。

```c
/**
   *@brief   初始化usart1_DMA的接收
   *@param   缓冲区1
   *@param   缓冲区2
   *@param   接收数据长度
   *@retval  无
   */
void usart1_rx_dma_init(uint8_t *rx1_buf, uint8_t *rx2_buf, uint16_t dma_buf_num)
{
    //使能DMA串口接收和发送
    SET_BIT(huart1.Instance->CR3, USART_CR3_DMAR);
    //使能空闲中断
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
    //失效DMA
    __HAL_DMA_DISABLE(&hdma_usart1_rx);   
	  //再次确认失效DMA
    while(hdma_usart1_rx.Instance->CR & DMA_SxCR_EN)
    {
        __HAL_DMA_DISABLE(&hdma_usart1_rx);
    }
    //清除传输完成中断标志
    __HAL_DMA_CLEAR_FLAG(&hdma_usart1_rx, DMA_LISR_TCIF1);
    //设置DMA数据流x外设地址为串口数据寄存器
    hdma_usart1_rx.Instance->PAR = (uint32_t) & (USART1->DR);
    //内存缓冲区1
    hdma_usart1_rx.Instance->M0AR = (uint32_t)(rx1_buf);
    //内存缓冲区2
    hdma_usart1_rx.Instance->M1AR = (uint32_t)(rx2_buf);
    //接收数据长度
    __HAL_DMA_SET_COUNTER(&hdma_usart1_rx, dma_buf_num);
    //使能双缓冲区
    SET_BIT(hdma_usart1_rx.Instance->CR, DMA_SxCR_DBM);
    //使能DMA
    __HAL_DMA_ENABLE(&hdma_usart1_rx);
}
```

通过该函数 进行 USART1 的 DMA 接收的初始化。在初始化时，使能 DMA串口接收和空闲中断，配置当外设数据到达之后的存储的缓冲区，在这里开启了双缓冲区功能，每一帧 sbus 数据为 18 字节，而开启的双缓冲区总大小为 36 字节，这样可以避免 DMA传输越界。

```c
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */
	receive_RC_data();
  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
```

```c
void receive_RC_data(void)
{
	//判断是否空闲中断
  if(USART1->SR & UART_FLAG_IDLE)
    {
        static uint16_t this_time_rx_len = 0;
       //清零IDLE标志，软件清零
        __HAL_UART_CLEAR_PEFLAG(&huart1);
         //判断进行接收的缓冲区是0号缓冲区还是1号缓冲区 
        if ((hdma_usart1_rx.Instance->CR & DMA_SxCR_CT) == RESET)
        {
            //失效DMA
            __HAL_DMA_DISABLE(&hdma_usart1_rx);
            //获取接收数据长度,长度 = 设定长度 - 剩余长度
            this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart1_rx.Instance->NDTR;
            //重新设定数据长度
            hdma_usart1_rx.Instance->NDTR = SBUS_RX_BUF_NUM;
            //设定缓冲区1
            hdma_usart1_rx.Instance->CR |= DMA_SxCR_CT;
            //使能DMA
            __HAL_DMA_ENABLE(&hdma_usart1_rx);
            
            if(this_time_rx_len == RC_FRAME_LENGTH)
            {
			//处理遥控器数据
               rc_callback_handler(&rc_ctrl, sbus_rx_buf[0]);
            }
        }
        else
        {
            //失效DMA
            __HAL_DMA_DISABLE(&hdma_usart1_rx);
            //获取接收数据长度,长度 = 设定长度 - 剩余长度
            this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart1_rx.Instance->NDTR;
            //重新设定数据长度
            hdma_usart1_rx.Instance->NDTR = SBUS_RX_BUF_NUM;
            //设定缓冲区0
            hdma_usart1_rx.Instance->CR &= ~(DMA_SxCR_CT);
            //使能DMA
            __HAL_DMA_ENABLE(&hdma_usart1_rx);
           //
            if(this_time_rx_len == RC_FRAME_LENGTH)
            {
                //处理遥控器数据
                rc_callback_handler(&rc_ctrl, sbus_rx_buf[1]);
            }
        }
    }
}
```

在完成初始化之后，每当 USART1 产生空闲中断时就会进入 USART1_IRQHandler 进行处理，在 USART1_IRQHandler 中，进行寄存器中断标志位的处理，然后判断进行接收的缓冲区是 1 号缓冲区还是 2 号缓冲区，使用设定长度减去剩余长度，获取本次 DMA 得到的数据的长度，判断是否与一帧数据（18 字节）长度相等，如果相等则调用函数 rc_callback_handler 进行遥控器数据的解码。

#### 2.CAN通信



#### 3.PWM控制



#### 4.底盘运动控制



#### 5.云台姿态控制



#### 6.射击控制





